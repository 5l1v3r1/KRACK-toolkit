#include "krack.h"

int main(int argc, char** argv) {
    int opt = 0;
    
    pcap_t* handle = NULL;
    char** filters = NULL;
    char* device_name = NULL;
    enum PN_TYPE pn = NSET;
    char error[PCAP_ERRBUF_SIZE];

    while((opt = getopt(argc, argv, "t:f:i:uh")) != -1) {
        if (optarg == NULL)
            continue;

        optarg = (char*)optarg;

        switch(opt) {
            case 'f': filters = get_pcap_filters(optarg); break;
            case 'i': device_name = optarg; break;
            case 't': pn = atoi(optarg); break;
            case 'h': usage(); break;
            case 'u': usage(); break;
            default: break;
        }
    }

    size_t ifaddrs_count = interface_count();
	struct ifaddrs* interfaces[ifaddrs_count];
	if (device_name == NULL || !strlen(device_name)) {
		interface_list(interfaces, ifaddrs_count);
        char* device_option = malloc(sizeof(char) * 2);

        for(size_t i = 0; i < ifaddrs_count; i++) {
            printf("%-3lu. %-10s [ %s ]\n",
                i + 1, interfaces[i]->ifa_name, get_interface_mac(interfaces[i]));
        } 
       
        puts("Please select an interface #: ");
        fgets(device_option, 2, stdin);
        int numeric_option = atoi(device_option);
        if (ifaddrs_count >=1 &&
                numeric_option <= ifaddrs_count &&
                numeric_option >= 1) {
                device_name = interfaces[numeric_option]->ifa_name; 
        }
        free(device_option);
	}

    device_name = pcap_lookupdev(error);

    if (device_name == NULL) {
        fprintf(stderr, "Device not found!: %s", error);
        exit(1);
    }

    pcap_create(device_name, error);
    handle = pcap_open_live(device_name, BUFSIZ, 0, TOL, error);
    
    if (pcap_can_set_rfmon(handle) == 0) {
        fprintf(stderr, "Can't put %s into monitor mode!", device_name);
        pcap_close(handle);
        exit(2);
    }

    pcap_set_promisc(handle, 1);
    pcap_set_snaplen(handle, BUFSIZ);
    pcap_set_timeout(handle, TOL);
    pcap_activate(handle);

    pcap_loop(handle, 0, krack_pcap_handler, NULL);
    pcap_set_promisc(handle, 0);
    pcap_close(handle);

    for (size_t i = 0; i < ifaddrs_count; i++) {
        if (interfaces[i] != NULL) {
            freeifaddrs(interfaces[i]);
        }
    }

    return 0;
}

void usage() {

    exit(0);
}

char** get_pcap_filters(char* filter_path) {
    char*  path = (filter_path == NULL ? "pcap.filters" : filter_path);
    FILE*  file = fopen(path, "r");
    char*  line = NULL;
    char** filters = NULL;

    if (file == NULL) {
        perror("Couldn't open pcap filter file: ");
    }
    
    fclose(file);
    return filters;
}

void krack_pcap_handler(uchar_ptr args, const struct pcap_pkthdr* header, c_uchar_ptr packet) {
    printf("packet cap len: %d\n", header->caplen);
    printf("packet total len: %d\n", header->len);

    struct Header* ip_header  = get_ip_header(packet);
    struct Header* tcp_header = get_tcp_header(packet);
    //const u_char* payload    = get_payload();

    if (ip_header  != NULL) free(ip_header);
    if (tcp_header != NULL) free(tcp_header);
}


